import java_cup.runtime.*;
import java_cup.*;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.List;
import java.util.ArrayList;

import ast.*;

action code
{:
  ast.Statechart statechart = null;
:}
parser code 
{:
  public void syntax_error(Symbol s){
    System.out.println("compiler has detected a syntax error at line " + s.left 
      + " column " + s.right+"Symbol <"+s.toString()+">");
  }
:}

non terminal ast.Statechart       statechart;
non terminal ast.State            state;
non terminal ast.Transition       transition;
non terminal ast.Name             name;
non terminal List<ast.State>      states;
non terminal List<ast.Transition> transitions;

non terminal ast.StatementList       statement_list;
non terminal ast.Statement           statement;
non terminal ast.AssignmentStatement assignment_statement;
non terminal ast.Expression          expr;

non terminal ast.DeclarationList decl_list;
non terminal ast.Declaration     decl;
non terminal ast.Declaration     normal_decl;
non terminal ast.Declaration     inp_decl;

non terminal List<ast.Struct> structs;
non terminal ast.Struct       struct;

non terminal ast.BooleanConstant boolconst;

non terminal String binop;

non terminal List<String> events;
non terminal List<String> eventlist;

// non terminal ast.Expression.Operator unaryop;

terminal String IDENTIFIER;
terminal Integer INTCONST;

terminal Symbol
    LBRACE, RBRACE, LPAREN, RPAREN, LPAR_SQ,RPAR_SQ,     /* Brackets                 */
    SEMICOLON, COLON, COMMA, DOT, HASH,                  /* Punctuations             */ 
    ASSIGN, OP_MESSAGE,
    WHILE, GOTO, DONE, IF, ELSE,                         /* Control flow             */
    STATECHART, STATE, TRANSITION,                       /* Statechart related       */
    ENTRY, EXIT,
    SRC, DEST, GUARD, ACTION,                            /* Transition label related */
    EVENTS,                                              /* Event related            */
    LIST, TUPLE, SET,                                    /* Containers               */
    IN,                                                  /* Set theoretic            */
    VAR, IVAR, DVAR, MVAR, INT, STRING,                  /* Variables related        */
    AND, OR, NOT,                                        /* Logical operators        */
    INC, DEC,                                            /* Increment, decrement     */
    EQ, NE, GE, GT, LE, LT,                              /* Relational operators     */
    SUB, ADD, MUL, DIV, UMIN, MOD,                       /* Arithmetic operators     */
    TRUE, FALSE,                                         /* Constants                */
    STRUCT, TYPE
    ;

precedence nonassoc LE, LT, EQ, NE, GE, GT;
precedence left LBRACE, RBRACE, AND, OR;
precedence left DOT;
precedence left ADD, SUB;
precedence left MUL, DIV;
precedence left UMIN;

start with statechart;

/*********** fully qualified names like s1.s11 ****************/
name ::=
    IDENTIFIER:id {:
      RESULT = new ast.Name(id);
    :}
  |  name:idlist DOT IDENTIFIER:id
    {:
      RESULT = idlist;
      RESULT.add(id);
    :}
  ;

/*********** skeletal statechart structure - begin *******/
statechart ::= 
    STATECHART IDENTIFIER:id LBRACE
      structs:structlist
      eventlist:el
      decl_list:dlist
      states:st transitions:tr
    RBRACE
    {:
      RESULT = new ast.Statechart(id, structlist, el, dlist, st, tr);
    :}
  ;

struct ::=
    STRUCT IDENTIFIER:id LBRACE
      decl_list:dlist
    RBRACE
    {:
      RESULT = new ast.Struct(id, dlist);
    :}
  ;

structs ::=
    structs:structlist struct:s 
    {:
      RESULT = structlist;
      for(ast.Struct st : structlist) {
        if(st.name.equals(s.name)) {
          throw new Exception("Duplicate struct name " + s.name);
        }
      }
      RESULT.add(s);
    :}
  | {:
       RESULT = new ArrayList<ast.Struct>();
    :}
  ;

eventlist ::=
    EVENTS LBRACE
      events:el
    RBRACE
    {:
      RESULT = el;
    :}
  |
    {:
      RESULT = new ArrayList<String>();
    :}
  ;

events ::=
    events:eventlist IDENTIFIER:e SEMICOLON
    {:
      RESULT = eventlist;
      for(String event : eventlist) {
        if(event.equals(e)) {
          throw new Exception("Duplicate event" + e);
        }
      }
      RESULT.add(e);
    :}
  | {:
       RESULT = new ArrayList<String>();
    :}
  ;

state ::= 
    STATE IDENTIFIER:id LBRACE
      decl_list:dlist
      states:st transitions:tr
    RBRACE
    {:
      RESULT = new ast.State(id, dlist, st, tr);
    :}
  ;

states ::=
    states:slist state:s 
    {:
      RESULT = slist;
      for(ast.State st : slist) {
        if(st.name.equals(s.name)) {
          throw new Exception("Duplicate state name " + s.name);
        }
      }
      RESULT.add(s);
    :}
  | {:
       RESULT = new ArrayList<ast.State>();
    :}
  ;

transition ::=
    TRANSITION IDENTIFIER:id LBRACE
      SRC  COLON name:src SEMICOLON
      DEST COLON name:des SEMICOLON
      GUARD COLON expr:g SEMICOLON
      ACTION COLON statement:a
    RBRACE
    {:
      RESULT = new ast.Transition(id, src, des, g, a);
    :}
  ;

transitions ::=
    transitions:tlist transition:t 
    {:
      RESULT = tlist;
      for(ast.Transition tr : tlist) {
        if(tr.name.equals(t.name)) {
          throw new Exception("Duplicate transition name " + t.name);
        }
      }
      RESULT.add(t);
    :}
  | {:
        RESULT = new ArrayList<ast.Transition>();
    :}
  ;
/*********** skeletal statechart structure - end *******/

/********** expressions for action language - begin ******/
expr ::=
    name:n {:
      RESULT = n;
    :}
  | expr:e1 binop:op expr:e2
    {:
      RESULT = new ast.BinaryExpression(e1, e2, op);
    :}
  | boolconst:e
    {:
      RESULT = e;
    :}
  | INTCONST:n
    {:
      RESULT = new ast.IntegerConstant(n);
    :}
  | LPAREN expr:e RPAREN
    {:
      RESULT = e;
    :} 
/*
  | unaryop:op expr:e
    {:
      RESULT = new UnaryExpression(e, op);
    :}
*/
  ;

boolconst ::=
    TRUE
    {:
      RESULT = new ast.BooleanConstant(true);
    :}
  | FALSE
    {:
      RESULT = new ast.BooleanConstant(false);
    :}
  ;

binop ::=
    ADD  {: RESULT = "+"; :}
  | MUL  {: RESULT = "*"; :}
  | SUB  {: RESULT = "-"; :}
  | DIV  {: RESULT = "/"; :}
  | GE   {: RESULT = ">="; :}
  | GT   {: RESULT = ">"; :}
  | LE   {: RESULT = "<="; :}
  | LT   {: RESULT = "<"; :}
  | EQ   {: RESULT = "="; :}
  | NE   {: RESULT = "!="; :}
  | AND  {: RESULT = "&&"; :}
  | OR   {: RESULT = "||"; :}
  ;

/*
unaryop ::=
    UMIN  {: RESULT = Expression.UMIN; };
  | NOT  {: RESULT = Expression.NOT; };
*/

statement_list::=
    statement_list:sl statement:s 
    {:
      sl.add(s);
      RESULT = sl;
    :}
  |
    {:
      RESULT = new ast.StatementList();
    :}
  ;

statement::=
    expr SEMICOLON
  | name:n ASSIGN expr:e SEMICOLON
    {:
      RESULT = new ast.AssignmentStatement(n, e);
    :}
  | LBRACE
      statement_list:sl
    RBRACE
    {:
      RESULT = sl;
    :}
  | IF expr:e statement:s1 ELSE statement:s2
    {:
      RESULT = new ast.IfStatement(e, s1, s2);
    :}
  | WHILE expr:e statement:s
    {:
      RESULT = new ast.WhileStatement(e, s);
    :}
  ;

decl_list ::= decl_list:dlist decl:d
    {:
      RESULT = dlist;
      if(!RESULT.add(d)) {
        throw new Exception("Duplication variable name '" + d.vname + "' declaration in same scope.");
      }
    :}
  | {:
      RESULT = new ast.DeclarationList();
    :}
  ;

decl ::=
     normal_decl:d
    {:
      RESULT = d;
    :}
  | inp_decl:d
    {:
     RESULT = d;
    :}
  ;

normal_decl ::=
     IDENTIFIER:id COLON IDENTIFIER:tid SEMICOLON
    {:
      RESULT = new ast.Declaration(id, tid, false);
    :}
  ;

inp_decl ::=
     IDENTIFIER:id HASH COLON IDENTIFIER:tid SEMICOLON
    {:
      RESULT = new ast.Declaration(id, tid, true);
    :}
  ;
